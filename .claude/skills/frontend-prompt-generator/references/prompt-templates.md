# 프론트엔드 개발 프롬프트 템플릿

## 프롬프트 구조 패턴

모든 프롬프트는 다음 구조를 따른다:

```
아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

[조건 섹션]

==============================================

[핵심요구사항 섹션]
```

## 섹션별 패턴

### 1. 조건 섹션

#### 조건-커서룰
```
조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @[추가 룰 파일들]
```

**적용 가이드:**
- 와이어프레임: `@01-common.mdc`, `@02-wireframe.mdc`
- UI 구현: `@01-common.mdc`, `@02-wireframe.mdc`, `@03-ui.mdc`
- 기능 구현: `@01-common.mdc`, `@04-func.mdc`

#### 조건-파일경로
```
조건-파일경로) [설명] 파일경로: [경로]
```

**예시:**
- `조건-파일경로) 구현될 TSX 파일경로: src/components/[컴포넌트명]/index.tsx`
- `조건-파일경로) 구현될 CSS 파일경로: src/components/[컴포넌트명]/styles.module.css`
- `조건-파일경로) 구현될 HOOK 파일경로: src/components/[컴포넌트명]/hooks/[기능명].hook.ts`
- `조건-파일경로) 구현될 TEST 파일경로: src/components/[컴포넌트명]/tests/[기능명].spec.ts`

#### 조건-피그마 (UI 구현 시)
```
조건-피그마) 활용할MCP: CursorTalkToFigmaMCP(채널명: [채널명])
조건-피그마) 구현될 컴포넌트 노드ID(main 영역): [노드ID]
```

#### 조건-공통목록 (UI 구현 시)
```
조건-공통목록) 사용할 색상 목록(global.css에 명시된 변수 토큰 활용)
            - 비슷한 토큰 선택하여 사용(하드코딩 금지)

조건-공통목록) 사용할 타이포그래피 목록(global.css에 명시된 변수 토큰 활용)
            - 비슷한 토큰 선택하여 사용(하드코딩 금지)
```

### 2. 핵심요구사항 섹션

프롬프트 타입에 따라 다른 구조를 사용한다.

## 프롬프트 타입별 템플릿

### 타입 1: 와이어프레임 구현

```
핵심요구사항) 완성된 컴포넌트를 페이지에서 import하여 연결시킬 것.
                - 연결될 경로: [페이지 경로]

핵심요구사항) HTML과 flexbox를 활용한 와이어프레임 구조만 만들어낼 것.

핵심요구사항) 각 영역은 아래의 수치값을 그대로 반영할 것. (단위: px)
                - {gap}: [너비] * [높이]
                - [영역명1]: [너비] * [높이]
                - {gap}: [너비] * [높이]
                - [영역명2]: [너비] * [높이]
                - ...
```

### 타입 2: UI 구현 (피그마 연동)

```
핵심요구사항) MCP를 연동하여 피그마의 디자인을 이미 만들어져있는 와이어프레임의 main 영역에 그대로 구현할 것.
```

### 타입 3: 데이터 바인딩

```
핵심요구사항) 다음의 기능을 playwright 테스트를 활용하여 TDD 기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.

1) 테스트 제외 라이브러리
- jest
- @testing-library/react

2) 테스트 조건
- timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
- 페이지가 완전히 로드된 후 테스트할 것.
  - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
  - **중요금지사항** 페이지 로드 식별 금지사항: networkidle 대기 방법

3) 테스트 API 조건
3-1) 데이터
- 실제 API 데이터를 사용할 것.
- Mock 데이터를 사용하지 말 것.

3-2) 성공 시나리오
- API 응답 데이터를 기반으로 바인딩

3-3) 실패 시나리오
- API 호출 실패 또는 빈 배열 처리

4) 데이터 조건
    - 저장소: 백엔드 서버(GraphQL API)
    - 요청방식: [쿼리명]
    - 요청 파라미터 구조:
    [GraphQL 쿼리]

핵심요구사항) 현재의 모든 구조를 그대로 유지하고, 하드코딩된 Mock데이터를 제거하고, 실제 [API명] 데이터를 바인딩할 것.

1) 바인딩할 데이터
- Apollo Client useQuery([쿼리명]) 결과

2) 데이터 바인딩 상세내용
- [필드명1]: [데이터 소스]
- [필드명2]: [데이터 소스]
- ...
- [조건부 처리 규칙]

3) CSS 처리
- [CSS 요구사항]

4) 테스트
- [테스트 요구사항]
```

### 타입 4: 라우팅/링크 기능

```
핵심요구사항) 다음의 기능을 playwright 테스트를 활용하여 TDD기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.
            1) 테스트 제외 라이브러리
                - jest
                - @testing-library/react

            2) 테스트 조건
                - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
                - 페이지가 완전히 로드된 후 테스트할 것.
                    - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
                    - 페이지 로드 식별 금지사항: networkidle 대기 방법
            
            3) 테스트 로컬스토리지 조건
                3-1) 데이터
                    - 실제데이터를 사용할 것.
                    - Mock데이터 사용하지 말 것.

                3-2) 성공시나리오
                    - 로컬스토리지 모킹하지 말 것.

                3-3) 실패시나리오
                    - 로컬스토리지 모킹하지 말 것.

            4) 테스트 데이터타입
                - 저장소: [저장소 타입]
                - key: [키명]
                - value: [데이터 구조]

핵심요구사항) 각 [요소명] 클릭시, url.ts의 페이지URL에 정의된 경로로 이동할 것.
            1) 경로: commons/constants/url.ts
            2) 조건
                - CSS는 cursor: pointer만 추가할 것.
                - 경로를 하드코딩하지 말고, url.ts를 import 하여 적용할 것.
                - 해당 [요소]에 바인딩된 [ID필드명]를 사용할 것.

            3) [요소] 영역
                - 전체: url.ts에 정의된 [페이지명] => [경로 패턴]
```

## 공통 패턴 규칙

### 들여쓰기
- 최상위 항목: 들여쓰기 없음
- 하위 항목: 16칸 들여쓰기 (공백 16개)
- 하위의 하위: 20칸 들여쓰기 (공백 20개)

### 번호 매기기
- 최상위: `1)`, `2)`, `3)`
- 하위: `1-1)`, `1-2)`, `2-1)`
- 하위의 하위: 불릿 포인트 (`-`)

### 구분선
- 섹션 구분: `==============================================` (46개 등호)

### 강조 표현
- 금지 사항: `**중요금지사항**`
- 필수 조건: `!` (예: `String!`)

### 코드 블록
- GraphQL 쿼리, 데이터 구조 등은 들여쓰기된 코드 블록으로 표현
